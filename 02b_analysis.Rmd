---
output: html_document
---
```{css, eval=T, echo=F}
pre code { overflow-x: scroll; white-space: pre; }
```
```{r setup, include=F}
# Uncomment to cheat and load pre-computed results to avoid waiting hours to regenerate an html render.
#knitr::opts_chunk$set(eval=F)
```
```{r cheat, eval=T, cache=T, include=F}
#load('medmod-250828.RData')
```

# Setup
```{r lib, eval=T, message=F}
#remotes::install_github("variani/lme4qtl")
library(data.table)
library(ggplot2)
library(ggrepel)
library(gtExtras)
library(lme4)
library(lme4qtl)
library(lmerTest)
library(lmtest)
library(mediation)
library(parallel)

options(mc.cores=4L)
options(datatable.na.strings=c('NA',''))

# Workaround so that lmerTest works on lme4qtl model objects
myLmer <- \(formula, data, relmat) {
  model <- relmatLmer(formula, data, relmat=relmat)
  lmerTest:::as_lmerModLT(model, as.function(model))
}
```
```{r data}
variants_of_interest <- fread(cmd='gcloud storage cat gs://fc-secure-4a392455-5587-4d6f-b8bd-01a1f834ae63/variants_of_interest.csv')
cpaids <- variants_of_interest$cpaid

data <- fread('analysis_df.csv')[
  ][, mesa_id    := as.factor(mesa_id)
  ][, exam       := as.factor(exam)
  # Variants are numeric (0/1/2), but we temporarily set to character so they don't get scale()'d.
  ][, names(.SD) := lapply(.SD, as.character), .SDcols=cpaids
  ][, names(.SD) := lapply(.SD, scale       ), .SDcols=is.numeric
  ][, names(.SD) := lapply(.SD, as.numeric  ), .SDcols=cpaids
]

data_exam1 <- data[exam==1]
data_exam2 <- data[exam==2]
data_exam3 <- data[exam==3]
data_exam4 <- data[exam==4]
data_exam5 <- data[exam==5]

load('mesa_km.RData') # Kinship (with ids remapped in script 01c)

numeric_colnms  <- names(data)[sapply(data,is.numeric)]
baseline_colnms <- paste0(numeric_colnms,'_0')
delta_colnms    <- paste0(numeric_colnms,'_Δ')
data[, (baseline_colnms) := .SD[exam==1],    .SDcols=numeric_colnms,     by='mesa_id'              ] |> invisible()
data[, (   delta_colnms) := data[,.SD,.SDcols=numeric_colnms] - data[,.SD,.SDcols=baseline_colnms] ] |> invisible()
#data[mesa_id %in% mesa_id[duplicated(mesa_id)], .SD, .SDcols=grepl('QI19074_HI|exam',names(data)), by='mesa_id'] # Sanity check

met_nms <- names(fread('metabolomics/QCd/merged_QCd.csv',nrows=0,drop=1))
covars <- c('site', 'sex', 'age', 'ses_score', 'drinks_per_week', 'smoking', 'ahei_score', paste0('gPC',1:5), paste0('gPC',1:5,'*mvpa_wins'), 'race')

calc_eff_n_metabolites <- \(met_nms) {
  met_nms <- met_nms[!is.na(met_nms)] |> unique()
  met_mtx <- data[ rowSums(is.na(data[,..met_nms]))==0, ..met_nms ] |> as.matrix(rownames=1) # Only samples having data for ALL metabolomics methods
  met_eigvals <- prcomp(met_mtx, scale=T, center=T)$sdev^2
  met_eff_n <- sum(met_eigvals)^2 / sum(met_eigvals^2)
}
```

# Define formulas
Main models of interest:

* __Metabolome-wide PA association analysis (MWAS)__: \
  `met ~ mvpa_wins + covars` \
* __HDL association analysis__: \
  `met ~ hdl_log + covars` \
* __Interaction Model__: \
  `hdl_log ~ met*SNP + sex*SNP + covars`
```{r fmlas}
runs <- CJ(met=met_nms, snp=cpaids, lm_or_lmm=c('LM','LMM'), exam=1,
  model=c('met~pa','met~hdl','met~snp',
          'hdl~met^2','hdl~met_RESET',
          'hdl~met*snp','hdl~Δmet*snp',

          'hdl~pa', 'hdl~pa_RESET', 'pa~snp',
          'hdl~pa*snp', 'hdl~pa*snp_no_sex*snp'))[

  # Exceptions
  ][!(lm_or_lmm=='LMM' & grepl('RESET',model))  # RESET models must be LMs
  ][!(lm_or_lmm=='LM'  & grepl(  'Δ'  ,model))  # Decomposed models must be LMMs
  ][!grepl('met',model), met := NA              # Rm per-met/per-snp rows for models w/o a met/snp term
  ][!grepl('snp',model), snp := NA
  ][lm_or_lmm=='LMM',    exam := NA
  ][!duplicated(paste(model,lm_or_lmm,exam,met,snp)) 


  # Basic associations
  ][model=='hdl~pa',  fmla := paste0( 'hdl_log', ' ~ ','mvpa_wins')
  ][model=='met~pa',  fmla := paste0(    met,    ' ~ ','mvpa_wins')
  ][model=='met~hdl', fmla := paste0(    met,    ' ~ ', 'hdl_log' )
  ][model=='met~snp', fmla := paste0(    met,    ' ~ ',    snp    )
  ][model=='pa~snp',  fmla := paste0('mvpa_wins',' ~ ',    snp    )

  # Nonlinearity
  ][model=='hdl~met^2',     fmla := paste0('hdl_log',' ~ ',    met,' + I(',met,'^2)')
  ][model=='hdl~met_RESET', fmla := paste0('hdl_log',' ~ ',    met                  )
  ][model=='hdl~pa_RESET',  fmla := paste0('hdl_log',' ~ ','mvpa_wins'              )

  # Interaction
  ][model=='hdl~pa*snp',            fmla := paste0('hdl_log',' ~ ','mvpa_wins','*',snp,' + ','sex','*',snp)
  ][model=='hdl~pa*snp_no_sex*snp', fmla := paste0('hdl_log',' ~ ','mvpa_wins','*',snp                    )
  ][model=='hdl~met*snp',           fmla := paste0('hdl_log',' ~ ',    met,    '*',snp,' + ','sex','*',snp)

  # hdl~met*snp model, except met term decomponsed into:        ↓baseline (exam1)   ↓delta (examX - exam1).
  ][model=='hdl~Δmet*snp', fmla := paste0('hdl_log',' ~ ',met,'_0','*',snp,' + ',met,'_Δ','*',snp,' + ','sex','*',snp)


  # Finalize
  ][, fmla := paste(fmla, '+', paste(covars,collapse='+'))           # Add covars common to all models
  ][model=='pa~snp', fmla := gsub('\\+gPC[0-9]\\*mvpa_wins','',fmla) #   (Except pa~snp shouldn't have pa itself in the covariates)
  ][lm_or_lmm=='LMM', fmla := paste(fmla, '+', '(1|mesa_id)')        # Add random intercept to all LMMs

  # Specify the term of interest whose stats will be extracted...
  # ...by specifying a pattern to grep (b/c interaction terms could be named either "met:snp" OR "snp:met").
  ][model %in% c('met~pa','hdl~pa'),                    term_pat := '^mvpa_wins$'
  ][model %in% c('met~hdl'),                            term_pat := '^hdl_log$'
  ][model %in% c('met~snp','pa~snp'),                   term_pat := paste0('^',snp,'$')
  ][model %in% c('hdl~met^2'),                          term_pat := paste0('I\\(',met,'\\^2\\)')
  ][model %in% c('hdl~met*snp'),                        term_pat := paste0(met,':',snp,'|',snp,':',met)
  ][model %in% c('hdl~Δmet*snp'),                       term_pat := paste0(met,'_Δ:',snp,'|',snp,':',met,'_Δ') # TODO extract baseline term too
  ][model %in% c('hdl~pa*snp','hdl~pa*snp_no_sex*snp'), term_pat := paste0('mvpa_wins:',snp,'|',snp,':mvpa_wins')
  ][is.na(term_pat), term_pat := 'NONE' # (grepping by NA would cause problems.)

] |> merge(by.x='met', by.y='unique_met_id', all=T, # Merge to metabolite metadata (M/Z, RT, common name, etc.)
           fread('metabolomics/met_info.csv')[unique_met_id %in% met_nms, .(unique_met_id,Method,MZ,RT,HMDB_ID,Metabolite)])
```

# Time to compute!
## Confirm HDL ~ PA assocation
Model: `log_hdl ~ mvpa_wins + covariates + (1|mesa_id)`
Only top 10 model terms are shown.
```{r confirm-hdl-pa, eval=T, echo=F}
runs[model=='hdl~pa' & lm_or_lmm=='LMM']$fmla |>
  myLmer(data, list(mesa_id=km)) |>
  summary() |> coef() |>
  as.data.table(keep.rownames='term') |>
  (\(dt) dt[order(`Pr(>|t|)`)])() |>
  head(10) |>
  gt() |>
  gt_highlight_rows(rows=term=='mvpa_wins')
```

## Confirm HDL ~ GxPA associations
Model: `log_hdl ~ snp*mvpa_wins + snp*sex + covars + (1|mesa_id)`
```{r confirm-hdl-gxpa, eval=T, echo=F}
runs[
  # Run models
  ][model=='hdl~pa*snp' & lm_or_lmm=='LM'
    , c('est','se',     't','p') := transpose(Map(fmla,term_pat, f=\(fmla,pat) {
        coefs <- summary(lm(fmla,data_exam1))$coefficients
        coefs[grepl(pat,rownames(coefs)),]
      }))
  ][model=='hdl~pa*snp' & lm_or_lmm=='LMM'
    , c('est','se','df','t','p') := transpose(Map(fmla,term_pat, f=\(fmla,pat) {
        coefs <- summary(myLmer(fmla,data,list(mesa_id=km)))$coefficients
        coefs[grepl(pat,rownames(coefs)),]
      }))

  # Display
  ][model=='hdl~pa*snp' & lm_or_lmm=='LMM'
  ][variants_of_interest, on=.(snp=cpaid)
  ][order(p)
  ][, .(snp,gene,rsid,analysis,annotation,GxPA_p=p)
] |> gt() |> gt_highlight_rows(rows=GxPA_p<0.05)
```

Moving foward with __only__ the two nomically-significant variants.
```{r subset-to-signif-hdl-gxpa}
signif_snps <- runs[model=='hdl~pa*snp' & lm_or_lmm=='LMM' & p < 0.05, snp]
runs <- runs[snp %in% signif_snps | is.na(snp)]
```

## Run all basic models
```{r run-all-basic-models, message=F}
i <- 0
runs <- runs[lm_or_lmm=='LM'
  , c('est','se',     't','p') := transpose(mcMap(fmla,term_pat, f=\(fmla,pat) {
      message('  ',(i<<-i+1)*getOption('mc.cores'),'/',.N,'\r',appendLF=F) # Progress bar
      s <- summary( lm(fmla, data_exam1) )                                 # Run model
      s$coefficients[grepl(pat,rownames(s$coefficients)),]                 # Extract results
}))]

i <- 0
runs <- runs[lm_or_lmm=='LMM'
  , c('est','se','df','t','p','singular_fit') := transpose(mcMap(fmla,term_pat, f=\(fmla,pat) {
      message('  ',(i<<-i+1)*getOption('mc.cores'),'/',.N,'\r',appendLF=F) # Progress bar
      s <- summary( myLmer(fmla, data, relmat=list(mesa_id=km)) )          # Run model
      c(s$coefficients[grepl(pat,rownames(s$coefficients)),],              # Extract results
        grepl('singular', s$optinfo$conv$lme4$messages)     )              # Extract singular fit warning msgs
}))]

i <- 0
runs <- runs[grepl('RESET',model)
  , p := transpose(mclapply(fmla, FUN=\(fmla) {
      message('  ',(i<<-i+1)*getOption('mc.cores'),'/',.N,'\r',appendLF=F) # Progress bar
      resettest(as.formula(fmla), data=data_exam1)$p.value                 # Run model & extract p
}))]
```

# Results summary
```{r get-signif-mets-and-thresholds, echo=F}
`p_thresh_mwas` <- 0.05/calc_eff_n_metabolites( unique(runs$met) )

runs[model=='met~pa' &
     p < p_thresh_mwas
     , signif_funnel := T]

`p_thresh_after_met~pa` <-
  runs[model=='met~pa' & signif_funnel==T,
       by=lm_or_lmm
       , .(thresh=0.05/calc_eff_n_metabolites(met))]

runs[by=lm_or_lmm,
     , runs[model=='met~hdl' &
            lm_or_lmm==.BY &
            p < `p_thresh_after_met~pa`[lm_or_lmm==.BY,thresh] &   # < p-val thresh for this step
            met %in% .SD[model=='met~pa' & signif_funnel==T, met] # Signif in previous step
            , signif_funnel := T
]] |> invisible()

`p_thresh_after_met~pa->met~hdl` <-
  runs[model=='met~hdl' & signif_funnel==T,
       by=lm_or_lmm
       , .(thresh=0.05/calc_eff_n_metabolites(met))]

runs[by=.(lm_or_lmm,snp),
     , runs[model=='hdl~met*snp' &
            lm_or_lmm==.BY['lm_or_lmm'] & snp==.BY['snp'] &
            p < `p_thresh_after_met~pa->met~hdl`[lm_or_lmm==.BY['lm_or_lmm'],thresh] & # < p-val thresh for this step
            met %in% runs[lm_or_lmm==.BY['lm_or_lmm'] & model=='met~hdl' & signif_funnel==T, met] # Signif in previous step
            , signif_funnel := T
]] |> invisible()

`p_thresh_after_met~pa->met~hdl->hdl~met*snp` <-
  runs[model=='hdl~met*snp' & signif_funnel==T,
       by=.(lm_or_lmm,snp)
       , .(thresh=tryCatch(expr=0.05/calc_eff_n_metabolites(met), error=\(e)0.05))]

# MWIS
runs[model=='hdl~met*snp' &
     p < p_thresh_mwas
     , signif_mwis := T]

#table(runs[,.(model,lm_or_lmm,    signif_funnel)])
#table(runs[,.(model,lm_or_lmm,snp,signif_funnel)])
#table(runs[,.(model,lm_or_lmm,snp,signif_mwis)])
#fwrite(runs,'tmp.csv')
```

```{r, include=F}
#save.image('all_models_p_threshes-250814.RData')
```

```{r, include=F, eval=T}
# Because the variable names need backticks, hard to display in markdown. So defining new names here.
n_signif_met_pa         <- runs[lm_or_lmm=='LMM' & model=='met~pa',  sum(signif_funnel,na.rm=T)]
n_signif_met_pa_met_hdl <- runs[lm_or_lmm=='LMM' & model=='met~hdl', sum(signif_funnel,na.rm=T)]
n_eff_mets_met_pa_met_hdl <- signif(0.05/`p_thresh_after_met~pa->met~hdl`[lm_or_lmm=='LMM',thresh],3)
```

Legend:

| Abbreviation | Result comes from which term in which model? | Description |
|:-------|:----------------------------------------|:-----------------|
| `hdl~met*snp`  | `hdl_log ~ `__`SNP*mvpa_wins`__` + SNP*sex + covars`                             | GxM interaction
| `hdl~Δmet*snp` | `hdl_log ~ `__`SNP*(met_exam1-met_examN)`__` + SNP*met_exam1 + SNP*sex + covars` | GxM interaction (decomposed)
| `met~snp`      | `met ~ `__`SNP`__` + covars`                                                     | Genetic main effect
| `hdl~met^2`    | `hdl_log ~ met + `__`met^2`__` + covars`                                         | Nonlinear effect
| `hdl~met_RESET`| `resettest(hdl_log ~ met_exam1 + covars)`                                        | RESET test p-value (exam1-only LM, not LMM)

## Genotype-independent models:
Total number of metabolites to start wtih: __`r length(met_nms)`__ (effective # of tests: `r signif(0.05/p_thresh_mwas,3)`).

| Model | Significant Metabolites |
|:------|:------------------------|
| `met ~ PA` MWAS                                                                 | `r n_signif_met_pa`         |
| `met ~ log(HDL)` (on `r n_signif_met_pa` significant metabolites from the MWAS) | `r n_signif_met_pa_met_hdl` |

## GxPA (analysis funnel)
Number of metabolites to start wtih: __`r n_signif_met_pa_met_hdl`__ (effective # of tests: `r n_eff_mets_met_pa_met_hdl`).

```{r, echo=F, eval=T}
runs[
  ][lm_or_lmm=='LMM'
  ][, .(Metabolite,met,snp,model,p=signif(p,3))
  ][runs[model=='hdl~met*snp' & lm_or_lmm=='LMM' & signif_funnel==T, .(met,snp)],
    on=.(met,snp)
  ][, dcast(.SD, value.var='p', Metabolite + met + snp ~ model)
  ][order(snp,`hdl~met*snp`)
  ][, `#` := 1:.N, by=snp
] |> gt() |> tab_header('Metabolite*SNP P-values', 'for metabolites significant from GxPA LMM analysis funnel')

runs[
  ][lm_or_lmm=='LMM' | grepl('RESET',model)
  ][, .(Metabolite,met,snp,model,signif_funnel,p=signif(p,3))
  ][is.na(snp) & met %in% runs[model=='hdl~met*snp' & lm_or_lmm=='LMM' & signif_funnel==T, met]
    , dcast(.SD, value.var='p', Metabolite + met ~ model)
] |> gt() |> tab_header('SNP-independent P-values', 'for metabolites significant from GxPA LMM analysis funnel')

```

## GxPA (MWIS)
Total number of metabolites to start wtih: __`r length(met_nms)`__ (effective # of tests: `r signif(0.05/p_thresh_mwas,3)`).

```{r, echo=F, eval=T}
runs[
  ][lm_or_lmm=='LMM'
  ][, .(Metabolite,met,snp,model,signif_funnel,p=signif(p,3))
  ][runs[model=='hdl~met*snp' & lm_or_lmm=='LMM' & signif_mwis==T, .(met,snp)],
    on=.(met,snp)
  ][, dcast(.SD, value.var='p', Metabolite + met + snp ~ model)
  ][order(snp,`hdl~met*snp`)
  ][, `#` := 1:.N, by=snp
] |> gt() |> tab_header('Metabolite*SNP P-values', 'for metabolites significant from GxPA LMM MWIS')

runs[
  ][lm_or_lmm=='LMM' | grepl('RESET',model)
  ][, .(Metabolite,met,snp,model,p=signif(p,3))
  ][is.na(snp) & met %in% runs[model=='hdl~met*snp' & lm_or_lmm=='LMM' & signif_mwis==T, met]
    , dcast(.SD, value.var='p', Metabolite + met ~ model)
] |> gt() |> tab_header('SNP-independent P-values', 'for metabolites significant from GxPA LMM MWIS')
```

## Write
```{r eval=F}
fwrite(runs,'runs.csv')
```

## Mediated moderation
```{r}
i <- 0
tmp2 <- runs[model=='hdl~met*snp' & (signif_funnel==T | signif_mwis==T), .(met,snp,lm_or_lmm)][
#tmp <- funion(`signif_mets_met~pa->met~hdl->hdl~met*snp`, `signif_mets_hdl~met*snp`)[
  # Calculate the minimum number of sims needed to pass the p-value threshold, plus a little 20% extra.
  ][, by=c(snp2='snp')
    #, n_sims := `p_thresh_after_met~pa->met~hdl->hdl~met*snp`[snp==snp2, ceiling(1.2/p)]
    #, n_sims := `p_thresh_after_hdl~met*snp`[snp==snp2, ceiling(1.2/p)]
    , n_sims := 200 # Nevermind, easier if we can just say p<5e-4

  # mediate() errored when I used a*b interaction terms in these models.
  # As a workaround I manually construct 'axb' product terms and use those instead.
  # See LabArchives days 250827-28 for my troubleshooting, but I never got to the bottom of it.
  ][, c('treat','mediator') := transpose(Map(snp,met, f=\(snp,met) {
        treat    <- paste0(snp,'x','mvpa_wins')
        mediator <- paste0(snp,'x',    met    )
        data[, (treat)    := .SD[[1]]*.SD[[2]], .SDcols=c(snp,'mvpa_wins')]
        data[, (mediator) := .SD[[1]]*.SD[[2]], .SDcols=c(snp,    met    )]
        c(treat,mediator)
      }))

  # Since we're not using 'a*b' formula syntax, have to manually add + a and + b terms.
  ][, fmla_mediator := paste0(snp,'x',met,' ~ ',snp,'x','mvpa_wins',' + ',met,' + ',snp,' + ','mvpa_wins'                  )
  ][, fmla_outcome  := paste0( 'hdl_log' ,' ~ ',snp,'x','mvpa_wins',' + ',met,' + ',snp,' + ','mvpa_wins',' + ',snp,'x',met)

  ## Finalize
  ][, fmla_mediator := paste(fmla_mediator, '+', paste(covars,collapse='+')) # Add covars
  ][, fmla_outcome  := paste(fmla_outcome,  '+', paste(covars,collapse='+'))
  ][lm_or_lmm=='LMM', fmla_mediator := paste(fmla_mediator, '+', '(1|mesa_id)') # Add random intercept
  ][lm_or_lmm=='LMM', fmla_outcome  := paste(fmla_outcome,  '+', '(1|mesa_id)')

  ][, c('ACME_p','mediation_prop','N') := transpose(mcMap(fmla_mediator,fmla_outcome,treat,mediator,n_sims,lm_or_lmm, f=\(fmla_m,fmla_y,treat,mediator,n_sims,lm_or_lmm) {
        message('  ',(i<<-i+1)*getOption('mc.cores'),'/',.N,'\n',appendLF=F) # Progress bar
        if(lm_or_lmm=='LMM') {
          model_m <- myLmer(fmla_m, data[!is.na(hdl_log)], relmat=list(mesa_id=km)) |> `class<-`('lmerMod')
          model_y <- myLmer(fmla_y, data                 , relmat=list(mesa_id=km)) |> `class<-`('lmerMod')
        } else {
          model_m <- lm(fmla_m, data[exam==1 & !is.na(hdl_log)])
          model_y <- lm(fmla_y, data[exam==1                  ])
        }
        mediate(
          model_m, model_y,
          treat=treat, mediator=mediator,
          sims=n_sims
        )[c('d0.p','n0','nobs')] # Extract only the ACME p-val, mediation proportion, and N.
      }))
]

#save.image('medmod-250926.RData')
```

```{r, echo=F, eval=T}
tmp[
  ][, .(met,snp,ACME_p,mediation_prop,N)
  ][order(snp,as.numeric(ACME_p))
  ][, `#` := 1:.N, by=snp
] |> gt() |> tab_header('Mediated Moderation Results', 'for metabolites significant from either GxPA MWIS or analysis funnel (the funnel ones are highlighted)') |>
  gt_highlight_rows(rows = met %in% `signif_mets_met~pa->met~hdl->hdl~met*snp`$met)
```

```{r}
tmp[grepl('14',snp) & mediation_prop<0] |> sum()
tmp[grepl('14',snp) & mediation_prop<0] |> sum()
```

Trying to investigate the negative mediation proportions.
```{r}
mets <- `signif_mets_met~pa->met~hdl->hdl~met*snp`[grepl('chr14',snp),met]
m1_fmla <- paste0(
  'hdl_log ~ mvpa_wins*chr14_88305056_G_A',
  #' + sex*chr14_88305056_G_A',
  ' + ',paste(collapse='+',covars),
  ' + (1|mesa_id)'
)
m2_fmlas <- paste0(
  'hdl_log ~ mvpa_wins*chr14_88305056_G_A + mvpa_wins*',mets,
  #' + sex*chr14_88305056_G_A',
  ' + ',paste(collapse='+',covars),
  ' + (1|mesa_id)'
)

tmp1 <-                             summary(myLmer(m1_fmla,data,list(mesa_id=km)))$coefficients |> signif(2) |> as.data.table(keep.rownames='term')
tmp2 <- lapply(m2_fmlas, \(m2_fmla) summary(myLmer(m2_fmla,data,list(mesa_id=km)))$coefficients |> signif(2) |> as.data.table(keep.rownames='term')) |> `names<-`(mets)

lapply(tmp2, \(t2)
  merge(t2,tmp1,by='term',all=T, suffixes=c('.M2','.M1'))[
    ][, .SD, .SDcols=!patterns('t val|df|Std')
    ][!grepl('site|smoking|race|gPC|age|sex|score|drink',term)
    #][, .(term, `hdl~pa*snp_est`=Estimate.M1,`hdl~pa*snp+pa*met_est`=Estimate.M2)
    #][, `!` := ''][grepl('chr14|^QI|^mvpa_wins$|mvpa_wins:QI',term), `!` := '!'
    #][order(-`!`)
    ][, .(term, `!`, `M1_est`=Estimate.M1,`M2_est`=Estimate.M2, M1_p=`Pr(>|t|).M1`, M2_p=`Pr(>|t|).M2`)
  ]
)


  ## Extra model to facilitate interpretation of mediation results
 # ][model=='hdl~pa*snp+pa*met_pa*snp', fmla := paste0('hdl_log',' ~ ~','mvpa_wins','*',snp,' + ','mvpa_wins','*',met)
 # ][model=='hdl~pa*snp+pa*met_pa*met', fmla := paste0('hdl_log',' ~ ~','mvpa_wins','*',snp,' + ','mvpa_wins','*',met)

```
