---
output: html_document
---
```{css, eval=T, echo=F}
pre code { overflow-x: scroll; white-space: pre; }
```
```{r setup, include=F}
# Uncomment to cheat and load pre-computed results to avoid waiting hours to regenerate an html render.
knitr::opts_chunk$set(eval=F)
```
```{r cheat, eval=T, cache=T, include=F}
#load('runs_w_lms2lmms_251012.RData') # Changed LMs to baseline-only km-adjusted LMMs.
#load('medmod-251014-lms2lmms.RData')
```

# Setup
```{r lib, eval=T, message=F}
#remotes::install_github("variani/lme4qtl")
library(data.table)
library(ggplot2)
library(ggrepel)
library(gtExtras)
library(lme4)
library(lme4qtl)
library(lmerTest)
library(lmtest)
library(mediation)
library(parallel)

options(datatable.na.strings=c('NA',''))

if(!file.exists('data/derived/analysis_df.csv')) system('gcloud storage cp gs://fc-secure-4a392455-5587-4d6f-b8bd-01a1f834ae63/data/derived/analysis_df.csv data/derived/')

# Workaround so that lmerTest works on lme4qtl model objects, so we can get lmerTest Satterthwaite p-values.
myLmer <- \(formula, data, relmat) {
  model <- relmatLmer(formula, data, relmat=relmat)
  lmerTest:::as_lmerModLT(model, as.function(model))
}
```
```{r data}
variants_of_interest <- fread(cmd='gcloud storage cat gs://fc-secure-4a392455-5587-4d6f-b8bd-01a1f834ae63/variants_of_interest.csv')
cpaids <- variants_of_interest$cpaid

data <- fread('data/derived/analysis_df.csv')[
  ][, mesa_id    := as.factor(mesa_id)
  ][, exam       := as.factor(exam)
  ][, batch_cn   := as.factor(batch_cn)
  # Variants are numeric (0/1/2), but we temporarily set to character so they don't get scale()'d.
  ][, names(.SD) := lapply(.SD, as.character), .SDcols=cpaids
  ][, names(.SD) := lapply(.SD, scale       ), .SDcols=is.numeric
  ][, names(.SD) := lapply(.SD, as.numeric  ), .SDcols=cpaids
]

# Better to subset upfront than in a loop, makes a big performance difference.
data_exam1 <- data[exam==1]
data_exam2 <- data[exam==2]
data_exam3 <- data[exam==3]
data_exam4 <- data[exam==4]
data_exam5 <- data[exam==5]

load('data/derived/genomics/mesa_km.RData') # Kinship (with ids remapped in script 01c)

# Create baseline-only and delta versions of all numeric variables, for the decomposed model.
numeric_colnms  <- names(data)[sapply(data,is.numeric)]
baseline_colnms <- paste0(numeric_colnms,'_0')
delta_colnms    <- paste0(numeric_colnms,'_Δ')
data[, (baseline_colnms) := .SD[exam==1],    .SDcols=numeric_colnms,     by='mesa_id'              ] |> invisible()
data[, (   delta_colnms) := data[,.SD,.SDcols=numeric_colnms] - data[,.SD,.SDcols=baseline_colnms] ] |> invisible()
#data[mesa_id %in% mesa_id[duplicated(mesa_id)], .SD, .SDcols=grepl('QI19074_HI|exam',names(data)), by='mesa_id'] # Sanity check

met_nms <- names(fread('data/derived/metabolomics/QCd/merged_QCd.csv',nrows=0,drop=1))
covars <- c('site', 'sex', 'age', 'ses_score', 'drinks_per_week', 'smoking', 'ahei_score', paste0('gPC',1:5), paste0('gPC',1:5,'*mvpa_wins'), 'race')

calc_eff_n_metabolites <- \(met_nms) {
  met_nms <- met_nms[!is.na(met_nms)] |> unique()
  met_mtx <- data[ rowSums(is.na(data[,..met_nms]))==0, ..met_nms ] |> as.matrix(rownames=1) # Only samples having data for ALL metabolomics methods
  met_eigvals <- prcomp(met_mtx, scale=T, center=T)$sdev^2
  met_eff_n <- sum(met_eigvals)^2 / sum(met_eigvals^2)
}
```

# Define formulas
Main models of interest:

* __Metabolome-wide PA association analysis (MWAS)__: \
  `met ~ mvpa_wins + covars` \
* __HDL association analysis__: \
  `met ~ hdl_log + covars` \
* __Interaction Model__: \
  `hdl_log ~ met*SNP + sex*SNP + covars`

```{r fmlas}
runs <- CJ(met=met_nms, snp=cpaids, single_exam=c(F,T), exam=1,
  model=c('met~pa','met~hdl','met~snp',
          'hdl~met^2','hdl~met_RESET',
          'hdl~met*snp','hdl~Δmet*snp',

          'hdl~pa', 'hdl~pa_RESET', 'pa~snp',
          'hdl~pa*snp', 'hdl~pa*snp-no_sex*snp'))[

  # Exceptions
  ][!(single_exam==F & grepl('RESET',model))  # RESET models must be LMs (which can't use longitudinal data)
  ][!(single_exam==T & grepl(  'Δ'  ,model))  # Decomposed models must be all-exams
  ][!grepl('met',model), met  := NA           # Rm per-met/per-snp rows for models w/o a met/snp term
  ][!grepl('snp',model), snp  := NA
  ][single_exam==F,      exam := NA
  ][!duplicated(paste(model,single_exam,exam,met,snp))


  # Basic associations
  ][model=='hdl~pa',  fmla := paste0( 'hdl_log', ' ~ ','mvpa_wins')
  ][model=='met~pa',  fmla := paste0(    met,    ' ~ ','mvpa_wins')
  ][model=='met~hdl', fmla := paste0(    met,    ' ~ ', 'hdl_log' )
  ][model=='met~snp', fmla := paste0(    met,    ' ~ ',    snp    )
  ][model=='pa~snp',  fmla := paste0('mvpa_wins',' ~ ',    snp    )

  # Nonlinearity
  ][model=='hdl~met^2',     fmla := paste0('hdl_log',' ~ ',    met,' + I(',met,'^2)')
  ][model=='hdl~met_RESET', fmla := paste0('hdl_log',' ~ ',    met                  )
  ][model=='hdl~pa_RESET',  fmla := paste0('hdl_log',' ~ ','mvpa_wins'              )

  # Interaction
  ][model=='hdl~pa*snp',            fmla := paste0('hdl_log',' ~ ','mvpa_wins','*',snp,' + ','sex','*',snp)
  ][model=='hdl~pa*snp-no_sex*snp', fmla := paste0('hdl_log',' ~ ','mvpa_wins','*',snp                    )
  ][model=='hdl~met*snp',           fmla := paste0('hdl_log',' ~ ',    met,    '*',snp,' + ','sex','*',snp)

  # hdl~met*snp model, except met term decomposed into:         ↓baseline (exam1)      ↓delta (examX - exam1).
  ][model=='hdl~Δmet*snp', fmla := paste0('hdl_log',' ~ ',met,'_0','*',snp,' + ',met,'_Δ','*',snp,' + ','sex','*',snp)


  # Finalize
  ][, fmla := paste(fmla, '+', paste(covars,collapse='+'))           # Add covars common to all models
  ][model=='pa~snp', fmla := gsub('\\+gPC[0-9]\\*mvpa_wins','',fmla) #   (Except pa~snp shouldn't have pa itself in the covariates)
  ][, #   (And which LC-MS batch variable to use depends on the metabolite's measurement method)
  ][, fmla := sapply(fmla, FUN=\(fmla) paste(fmla,
        fifelse(grepl(   'C8_pos', fmla), '+ batch_cp',
        fifelse(grepl(  'C18_neg', fmla), '+ batch_cn', # Warning: code will silently break if you change the suffixes on metabolite names
        fifelse(grepl('HILIC_pos', fmla), '+ batch_hp',
        fifelse(grepl('Amide_neg', fmla), '+ batch_an', ''))))
      ))
  ][!grepl('RESET',model), fmla := paste(fmla, '+', '(1|mesa_id)')   # Add random intercept to all non-RESET models

  # Specify the term of interest whose stats will be extracted...
  # ...by specifying a pattern to grep (b/c interaction terms could be named either "met:snp" OR "snp:met").
  ][model %in% c('met~pa','hdl~pa'),                    term_pat := '^mvpa_wins$'
  ][model %in% c('met~hdl'),                            term_pat := '^hdl_log$'
  ][model %in% c('met~snp','pa~snp'),                   term_pat := paste0('^',snp,'$')
  ][model %in% c('hdl~met^2'),                          term_pat := paste0('I\\(',met,'\\^2\\)')
  ][model %in% c('hdl~met*snp'),                        term_pat := paste0(met,':',snp,'|',snp,':',met)
  ][model %in% c('hdl~Δmet*snp'),                       term_pat := paste0(met,'_Δ:',snp,'|',snp,':',met,'_Δ')
  ][, rbind(.SD, .SD[model %in% c('hdl~Δmet*snp')][,    term_pat := paste0(met,'_0:',snp,'|',snp,':',met,'_0')])
  ][model %in% c('hdl~pa*snp','hdl~pa*snp-no_sex*snp'), term_pat := paste0('mvpa_wins:',snp,'|',snp,':mvpa_wins')
  ][is.na(term_pat), term_pat := 'NONE' # (grepping by NA would cause problems.)

] |> merge(by.x='met', by.y='unique_met_id', all=T, # Merge to metabolite metadata (M/Z, RT, common name, etc.)
           fread('data/derived/metabolomics/met_info.csv')[unique_met_id %in% met_nms, .(unique_met_id,Method,MZ,RT,HMDB_ID,Metabolite)])
```

# Time to compute!
## Confirm HDL ~ PA assocation
Model: `log_hdl ~ mvpa_wins + covariates + (1|mesa_id)`
Only top 10 model terms are shown.
```{r confirm-hdl-pa, eval=T, echo=F}
runs[model=='hdl~pa' & single_exam==F]$fmla |>
  myLmer(data, list(mesa_id=km)) |>
  summary() |> coef() |>
  as.data.table(keep.rownames='term') |>
  (\(dt) dt[order(`Pr(>|t|)`)])() |>
  head(10) |>
  gt() |>
  gt_highlight_rows(rows=term=='mvpa_wins')
```

## Confirm HDL ~ GxPA associations
Model: `log_hdl ~ snp*mvpa_wins + snp*sex + covars + (1|mesa_id)`
```{r confirm-hdl-gxpa, eval=T, echo=F}
runs[
  # Run models
  ][model=='hdl~pa*snp' & single_exam==T
    , c('est','se','df','t','p') := transpose(Map(fmla,term_pat, f=\(fmla,pat) {
        coefs <- summary(myLmer(fmla,data_exam1,list(mesa_id=km)))$coefficients
        coefs[grepl(pat,rownames(coefs)),]
      }))
  ][model=='hdl~pa*snp' & single_exam==F
    , c('est','se','df','t','p') := transpose(Map(fmla,term_pat, f=\(fmla,pat) {
        coefs <- summary(myLmer(fmla,data      ,list(mesa_id=km)))$coefficients
        coefs[grepl(pat,rownames(coefs)),]
      }))

  # Display
  ][model=='hdl~pa*snp' & single_exam==F
  ][variants_of_interest, on=.(snp=cpaid)
  ][order(p)
  ][, .(SNP=snp,Gene=gene,rsID=rsid,analysis,Annotation=annotation,GxMVPA_p=p, GxMVPA_β=est)

  # Lipid-PA-only mode
  ][analysis=='PA-Lipid'
  ][, .(SNP,Gene,rsID,Annotation,GxMVPA_p,GxMVPA_β)
] |> gt() |> gt_highlight_rows(rows=GxMVPA_p<0.05)
```

Moving foward with __only__ the two nomically-significant variants.
```{r subset-to-signif-hdl-gxpa}
signif_snps <- runs[model=='hdl~pa*snp' & single_exam==F & p < 0.05, snp]
runs <- runs[snp %in% signif_snps | is.na(snp)]
```

## Run all basic models
```{r run-all-basic-models, message=F}
# These models are quite memory intensive, and that multiplies when they're run in parallel.

# To avoid crashes, you'll need ~10GB per core.
options(mc.cores=2L)
i <- 0
runs <- runs[single_exam==T & !grepl('RESET',model)
  , c('est','se','df','t','p','singular_fit') := transpose(mcMap(fmla,term_pat, f=\(fmla,pat) {
      message('  ',(i<<-i+1)*getOption('mc.cores'),'/',.N,'\r',appendLF=F) # Progress bar
      s <- summary( myLmer(fmla, data_exam1, relmat=(list(mesa_id=km))) )  # Run model
      c(s$coefficients[grepl(pat,rownames(s$coefficients)),],              # Extract results
        any(grepl('singular', s$optinfo$conv$lme4$messages)))              # Extract singular fit warning msgs
}))]

# To avoid crashes, you'll need ~20GB per core.
options(mc.cores=1L)
i <- 0
runs <- runs[single_exam==F
  , c('est','se','df','t','p','singular_fit') := transpose(mcMap(fmla,term_pat, f=\(fmla,pat) {
      message('  ',(i<<-i+1)*getOption('mc.cores'),'/',.N,'\r',appendLF=F) # Progress bar
      s <- summary( myLmer(fmla, data      , relmat=list(mesa_id=km)) )    # Run model
      c(s$coefficients[grepl(pat,rownames(s$coefficients)),],              # Extract results
        any(grepl('singular', s$optinfo$conv$lme4$messages)))              # Extract singular fit warning msgs
}))]

# Requires a trivial amount of memory.
options(mc.cores=6L)
i <- 0
runs <- runs[grepl('RESET',model)
  , p := transpose(mclapply(fmla, FUN=\(fmla) {
      message('  ',(i<<-i+1)*getOption('mc.cores'),'/',.N,'\r',appendLF=F) # Progress bar
      resettest(as.formula(fmla), data=data_exam1)$p.value                 # Run model & extract p
}))]
```

# Results summary
## Calculate p-value thresholds, mark metabolites which pass
```{r p-thresholds, eval=T, echo=F}
`p_thresh_mwas` <- 0.05/calc_eff_n_metabolites( unique(runs$met) )

runs[model=='met~pa' &
     p < p_thresh_mwas
     , signif_funnel := T] |> invisible()

`p_thresh_after_met~pa` <-
  runs[model=='met~pa' & signif_funnel==T,
       by=single_exam
       , .(thresh=0.05/calc_eff_n_metabolites(met))]

runs[by=single_exam,
     , runs[model=='met~hdl' &
            single_exam==.BY &
            p < `p_thresh_after_met~pa`[single_exam==.BY,thresh] &   # < p-val thresh for this step
            met %in% .SD[model=='met~pa' & signif_funnel==T, met] # Signif in previous step
            , signif_funnel := T
]] |> invisible()

`p_thresh_after_met~pa->met~hdl` <-
  runs[model=='met~hdl' & signif_funnel==T,
       by=single_exam
       , .(thresh=0.05/calc_eff_n_metabolites(met))]

runs[by=.(single_exam,snp),
     , runs[model=='hdl~met*snp' &
            single_exam==.BY['single_exam'] & snp==.BY['snp'] &
            p < `p_thresh_after_met~pa->met~hdl`[single_exam==.BY['single_exam'],thresh] & # < p-val thresh for this step
            met %in% runs[single_exam==.BY['single_exam'] & model=='met~hdl' & signif_funnel==T, met] # Signif in previous step
            , signif_funnel := T
]] |> invisible()

`p_thresh_after_met~pa->met~hdl->hdl~met*snp` <-
  runs[model=='hdl~met*snp' & signif_funnel==T,
       by=.(single_exam,snp)
       , .(thresh=tryCatch(expr=0.05/calc_eff_n_metabolites(met), error=\(e)0.05))]

# MWIS
runs[model=='hdl~met*snp' &
     p < p_thresh_mwas
     , signif_mwis := T] |> invisible()

`p_thresh_after_hdl~met*snp` <-
  runs[model=='hdl~met*snp' & signif_mwis==T,
       by=.(single_exam,snp)
       , .(thresh=tryCatch(expr=0.05/calc_eff_n_metabolites(met), error=\(e)0.05))]
```
```{r checkpoint-main, eval=F, include=F}
#save.image('runs_w_lms2lmms_251012.RData')
```

```{r n-signif, include=F, eval=T}
# Because the variable names need backticks, hard to display in markdown. So defining new names here.
n_signif_met_pa         <- runs[single_exam==F & model=='met~pa',  sum(signif_funnel,na.rm=T)]
n_signif_met_pa_met_hdl <- runs[single_exam==F & model=='met~hdl', sum(signif_funnel,na.rm=T)]
n_eff_mets_met_pa_met_hdl <- signif(0.05/`p_thresh_after_met~pa->met~hdl`[single_exam==F,thresh],3)
```

Legend:

| Abbreviation | Result comes from which term in which model? | Description |
|:-------|:----------------------------------------|:-----------------|
| `hdl~met*snp`  | `hdl_log ~ `__`SNP*mvpa_wins`__` + SNP*sex + covars`                             | GxM interaction
| `hdl~Δmet*snp` | `hdl_log ~ `__`SNP*(met_exam1-met_examN)`__` + SNP*met_exam1 + SNP*sex + covars` | GxM interaction (decomposed)
| `met~snp`      | `met ~ `__`SNP`__` + covars`                                                     | Genetic main effect
| `hdl~met^2`    | `hdl_log ~ met + `__`met^2`__` + covars`                                         | Nonlinear effect
| `hdl~met_RESET`| `resettest(hdl_log ~ met_exam1 + covars)`                                        | RESET test p-value (exam1-only LM, not LMM)

## Genotype-independent models:
Total number of metabolites to start wtih: __`r length(met_nms)`__ (effective # of tests: `r signif(0.05/p_thresh_mwas,3)`).

| Model | Significant Metabolites |
|:------|:------------------------|
| `met ~ PA` MWAS                                                                 | `r n_signif_met_pa`         |
| `met ~ log(HDL)` (on `r n_signif_met_pa` significant metabolites from the MWAS) | `r n_signif_met_pa_met_hdl` |

## GxPA (analysis funnel)
Number of metabolites to start wtih: __`r n_signif_met_pa_met_hdl`__ (effective # of tests: `r n_eff_mets_met_pa_met_hdl`).

```{r tbl-funnel, echo=F, eval=T}
runs[
  ][single_exam==F
  ][!grepl('_0',term_pat)
  ][, .(Metabolite,met,snp,model,p=signif(p,3))
  ][runs[model=='hdl~met*snp' & single_exam==F & signif_funnel==T, .(met,snp)],
    on=.(met,snp)
  ][, dcast(.SD, value.var='p', Metabolite + met + snp ~ model)
  ][order(snp,`hdl~met*snp`)
  ][, `#` := 1:.N, by=snp
] |> gt() |> tab_header('Metabolite*SNP P-values', 'for metabolites significant from GxPA LMM analysis funnel')

runs[
  ][single_exam==F | grepl('RESET',model)
  ][, .(Metabolite,met,snp,model,signif_funnel,p=signif(p,3))
  ][is.na(snp) & met %in% runs[model=='hdl~met*snp' & single_exam==F & signif_funnel==T, met]
    , dcast(.SD, value.var='p', Metabolite + met ~ model)
] |> gt() |> tab_header('SNP-independent P-values', 'for metabolites significant from GxPA LMM analysis funnel')

```

## GxPA (MWIS)
Total number of metabolites to start wtih: __`r length(met_nms)`__ (effective # of tests: `r signif(0.05/p_thresh_mwas,3)`).

```{r tbl-mwis, echo=F, eval=T}
runs[
  ][single_exam==F
  ][!grepl('_0',term_pat)
  ][, .(Metabolite,met,snp,model,signif_funnel,p=signif(p,3))
  ][runs[model=='hdl~met*snp' & single_exam==F & signif_mwis==T, .(met,snp)],
    on=.(met,snp)
  ][, dcast(.SD, value.var='p', Metabolite + met + snp ~ model)
  ][order(snp,`hdl~met*snp`)
  ][, `#` := 1:.N, by=snp
] |> gt() |> tab_header('Metabolite*SNP P-values', 'for metabolites significant from GxPA LMM MWIS')

runs[
  ][single_exam==F | grepl('RESET',model)
  ][, .(Metabolite,met,snp,model,p=signif(p,3))
  ][is.na(snp) & met %in% runs[model=='hdl~met*snp' & single_exam==F & signif_mwis==T, met]
    , dcast(.SD, value.var='p', Metabolite + met ~ model)
] |> gt() |> tab_header('SNP-independent P-values', 'for metabolites significant from GxPA LMM MWIS')
```

### More detail on the estimates for signif GxM metabolites
Just for the significant metabolites, rerun the models to extract estimates for more terms.
```{r gxm-detailed-estimates-models, eval=T}
i<-0
options(mc.cores=4L) # Fewer models, so the number of cores can be brought up with less risk of crashing.
gxm_betas <- runs[
  ][model=='hdl~met*snp' & (signif_mwis==T | signif_funnel==T) & single_exam==F
  ][
    , c('intercept',
        'g_est',  'g_se',  'g_df',  'g_t',  'g_p',
        'm_est',  'm_se',  'm_df',  'm_t',  'm_p',
        'gxm_est','gxm_se','gxm_df','gxm_t','gxm_p'
      ) := transpose(mcMap(fmla,term_pat,met,snp, f=\(fmla,pat,met,snp) {
        message('  ',(i<<-i+1)*getOption('mc.cores'),'/',.N,'\r',appendLF=F) # Progress bar
        s <- summary( myLmer(fmla, data, relmat=list(mesa_id=km)) )          # Run model
        snp_pat <- paste0('^',snp,'$')
        met_pat <- paste0('^',met,'$')
        gxm_pat <- pat
        c(s$coefficients['(Intercept)','Estimate'                ],
          s$coefficients[grepl(snp_pat,rownames(s$coefficients)),], # Extract G   stuff
          s$coefficients[grepl(met_pat,rownames(s$coefficients)),], # Extract   M stuff
          s$coefficients[grepl(gxm_pat,rownames(s$coefficients)),]) # Extract GxM stuff
}))]
```
```{r tbl-gxm-detailed, eval=T, echo=F}
# Basic table
#gxm_betas[
#  ][single_exam==F & grepl(14,snp)
#  ][, .(Metabolite,met,signif_funnel,signif_mwis,est_G=round(g_est,3),est_M=round(m_est,3),est_GxM=signif(gxm_est,3),P_g=signif(g_p,3),P_m=signif(m_p,3),P_GxM=signif(gxm_p,3))
#] |> gt() |> tab_header('Metabolite*SNP P-values', 'for metabolites significant from GxPA LMM MWIS')

`β(p)` <- \(β,p) paste0(round(β,3),' (',signif(p,3),')')

# Fancy table
gxm_betas[
  ][single_exam==F & grepl(14,snp)
  ][on=.(met,snp),
    runs[single_exam==F & model=='met~snp' & met %in% gxm_betas$met
         , .(met,snp,mg_est=est,mg_p=p)]
  ][on=.(met),
    runs[single_exam==F & model=='met~hdl' & met %in% gxm_betas$met
         , .(met,my_est=est,my_p=p)]
  ][on=.(met),
    runs[single_exam==F & model=='met~pa' & met %in% gxm_betas$met
         , .(met,me_est=est,me_p=p)]
  ][order(gxm_p)
  ][is.na(Metabolite), Metabolite := ''
  ][, .(`Metabolite ID`=met,Identity=Metabolite,signif_funnel,signif_mwis,
        βMG=`β(p)`(mg_est,mg_p),
        βME=`β(p)`(me_est,me_p),
        βMY=`β(p)`(my_est,my_p),
        #βG=`β(p)`(g_est,g_p),
        βM=`β(p)`(m_est,m_p),
        βGxM=`β(p)`(gxm_est,gxm_p))
  ][signif_funnel==T | signif_mwis==T
] |> gt() |>
  tab_header('Metabolite*SNP P-values', 'for metabolites significant from GxPA LMM MWIS') |>
  tab_footnote(md('Genetic effect from the model: __Metabolite ~ SNP__'),
    locations = cells_column_labels(columns = βMG)
  ) |>
  tab_footnote(md('log(HDL) effect from the model: __Metabolite ~ log(HDL)__'),
    locations = cells_column_labels(columns = βMY)
  ) |>
  tab_footnote(md('MVPA effect from the model: __Metabolite ~ MVPA__'),
    locations = cells_column_labels(columns = βME)
  ) |>
  #tab_footnote(md('Main genetic effect from the interaction model: __log(HDL) ~ Metabolite + SNP + Metabolite*SNP__'),
  #  locations = cells_column_labels(columns = β_G)
  #) |>
  tab_footnote(md('Metabolite effect from the interaction model: __log(HDL) ~ Metabolite + SNP + Metabolite*SNP__'),
    locations = cells_column_labels(columns = βM)
  ) |>
  tab_footnote(md('Interaction effect from the interaction model'),
    locations = cells_column_labels(columns = βGxM)
  ) |>
  tab_footnote(md('Format: β (p-value)')) |>
  tab_footnote(md('Interpretation: if β = 1, the outcome increases by one SD per SD of the indepdendent variable.')) |>
  tab_footnote(md('(If the SNP is the independent variable, β = 1 represents that the outcome increases by 1 SD if the SNP is present).'))
```

## Write
```{r write-main, eval=F}
fwrite(runs,'runs.csv')
```

# Mediated moderation
```{r meMO}
i <- 0
options(mc.cores=1L) # Really memory-hungry, probably only run one at a time.
meMO <- runs[model=='hdl~met*snp' & (signif_funnel==T | signif_mwis==T), .(met,snp,single_exam)][
  # Calculate the minimum number of sims needed to pass the p-value threshold, plus a little 20% extra.
  ][, by=c(snp2='snp')
    #, n_sims := `p_thresh_after_met~pa->met~hdl->hdl~met*snp`[snp==snp2, ceiling(1.2/p)]
    #, n_sims := `p_thresh_after_hdl~met*snp`[snp==snp2, ceiling(1.2/p)]
    , n_sims := 1000 # Nevermind, easier if we can just say p<1e-3

  # mediate() errored when I used a*b interaction terms in these models.
  # As a workaround I manually construct 'axb' product terms and use those instead.
  # See LabArchives days 250827-28 for my troubleshooting, but I never got to the bottom of it.
  ][, c('treat','mediator') := transpose(Map(snp,met, f=\(snp,met) {
        treat    <- paste0(snp,'x','mvpa_wins')
        mediator <- paste0(snp,'x',    met    )
        data[, (treat)    := .SD[[1]]*.SD[[2]], .SDcols=c(snp,'mvpa_wins')]
        data[, (mediator) := .SD[[1]]*.SD[[2]], .SDcols=c(snp,    met    )]
        c(treat,mediator)
      }))

  # Since we're not using 'a*b' formula syntax, have to manually add + a and + b terms.
  ][, fmla_mediator := paste0(snp,'x',met,' ~ ',snp,'x','mvpa_wins',' + ',met,' + ',snp,' + ','mvpa_wins'                  )
  ][, fmla_outcome  := paste0( 'hdl_log' ,' ~ ',snp,'x','mvpa_wins',' + ',met,' + ',snp,' + ','mvpa_wins',' + ',snp,'x',met)

  ## Finalize
  ][, fmla_mediator := paste(fmla_mediator, '+', paste(covars,collapse='+')) # Add covars
  ][, fmla_outcome  := paste(fmla_outcome,  '+', paste(covars,collapse='+'))
  ][, fmla_mediator := paste(fmla_mediator, '+', '(1|mesa_id)') # Add random intercept
  ][, fmla_outcome  := paste(fmla_outcome,  '+', '(1|mesa_id)')

  ][, c('ACME_p','mediation_prop','N') := transpose(mcMap(fmla_mediator,fmla_outcome,treat,mediator,n_sims,single_exam, f=\(fmla_m,fmla_y,treat,mediator,n_sims,single_exam) {
        message('  ',(i<<-i+1)*getOption('mc.cores'),'/',.N,'\r',appendLF=F) # Progress bar
        if(single_exam==F) {
          model_m <- myLmer(fmla_m, data[!is.na(hdl_log)], relmat=list(mesa_id=km)) |> `class<-`('lmerMod')
          model_y <- myLmer(fmla_y, data                 , relmat=list(mesa_id=km)) |> `class<-`('lmerMod')
        } else {
          model_m <- myLmer(fmla_m, data[exam==1 & !is.na(hdl_log)], relmat=list(mesa_id=km)) |> `class<-`('lmerMod')
          model_y <- myLmer(fmla_y, data[exam==1                  ], relmat=list(mesa_id=km)) |> `class<-`('lmerMod')
        }
        mediate(
          model_m, model_y,
          treat=treat, mediator=mediator,
          sims=n_sims
        )[c('d0.p','n0','nobs')] # Extract only the ACME p-val, mediation proportion, and N.
      }))
]
```
```{r checkpoint-meMO, eval=F, include=F}
#save(meMO, file='medmod-251014-lms2lmms.RData')
```

```{r tbl-meMO, echo=F, eval=T}
meMO[
  ][on=.(met),
    runs[met %in% meMO$met, .(met,Metabolite)][!duplicated(met)]
  ][ACME_p < 0.023147 # TODO use `p_thresh_after_met~pa->met~hdl->hdl~met*snp` instead
  ][single_exam==F
  ][order(snp, as.numeric(ACME_p), as.numeric(mediation_prop))
  ][order(snp, !met %in% runs[model=='hdl~met*snp' & signif_funnel, met]) # Order so that funnel metabolites are first
  ][, `#` := 1:.N, by=snp
  ][, .(`Metabolite ID`=met,Identity=Metabolite,snp,ACME_p,mediation_prop,N,`#`)
  ][grepl(14,snp)][,-c('snp','#')
] |>
  gt() |>
  tab_header('chr14_88305056_G_A Longitudinal Mediated Moderation Results', 'for metabolites significant from either GxPA MWIS or analysis funnel (the funnel ones are highlighted)') |>
  gt_highlight_rows(rows = `Metabolite ID` %in% runs[model=='hdl~met*snp' & signif_funnel, met]) |>
  tab_footnote('Models run using 1000 simulations; p-values rounded to the nearest 0.001.',
    locations = cells_column_labels(columns = ACME_p)
  )
```

## Number of significant hits at each step
Count the number of significant meMO metabolites:
```{r n-signif-meMO, eval=T}
meMO[by=.(single_exam,snp),
     , meMO[single_exam==.BY['single_exam'] & snp==.BY['snp'] &
            ACME_p < `p_thresh_after_met~pa->met~hdl->hdl~met*snp`[single_exam==.BY['single_exam'] & snp==.BY['snp'],thresh] &
            met %in% runs[single_exam==.BY['single_exam'] & model=='hdl~met*snp' & signif_funnel==T, met]
            , signif_funnel := T
]] |> invisible()

meMO[by=.(single_exam,snp),
     , meMO[single_exam==.BY['single_exam'] & snp==.BY['snp'] &
            ACME_p < `p_thresh_after_hdl~met*snp`[single_exam==.BY['single_exam'] & snp==.BY['snp'],thresh] &
            met %in% runs[single_exam==.BY['single_exam'] & model=='hdl~met*snp' & signif_mwis==T, met]
            , signif_mwis := T
]] |> invisible()
```
```{r tbl-n-signif, eval=T}
runs     [model=='met~pa',      .(`met~pa`              =sum(signif_funnel,na.rm=T)), by=.(single_exam)
   ][on=.(single_exam),
     runs[model=='met~hdl',     .(`met~hdl`             =sum(signif_funnel,na.rm=T)), by=.(single_exam)]
   ][on=.(single_exam),
     runs[model=='hdl~met*snp', .(`hdl~met*snp (funnel)`=sum(signif_funnel,na.rm=T)), by=.(single_exam,snp)]
   ][on=.(single_exam,snp),
     meMO[                    , .(`meMO (funnel)`       =sum(signif_funnel,na.rm=T)), by=.(single_exam,snp)]
   ][on=.(single_exam,snp),
     runs[model=='hdl~met*snp', .(`hdl~met*snp (MWIS)`  =sum(signif_mwis,  na.rm=T)), by=.(single_exam,snp)]
   ][on=.(single_exam,snp),
     meMO[                    , .(`meMO (MWIS)`         =sum(signif_mwis,  na.rm=T)), by=.(single_exam,snp)]
   ][order(snp,-single_exam)
   ][grepl('14',snp)][,snp:=NULL
   ][, `:=`(Model=fifelse(single_exam,'Baseline','Longitudinal'), single_exam=NULL)
   ][order(-Model)
] |>
  setcolorder(c('Model')) |>
  gt() |>
  tab_header('Number of significant metabolites after each step', 'with baseline vs. longitudinal comparison')
```

## Decomposed model bargraph
```{r plot-decomposed, eval=T}
df <-
copy(runs[
     model %in% c('hdl~met*snp', 'hdl~Δmet*snp') &
     met %in% runs[model=='hdl~met*snp' & signif_funnel==T & single_exam==F & grepl('14',snp), met] &
     snp == 'chr14_88305056_G_A'
   ])[, z := est/se
   ][, Source := factor(
         fifelse(grepl('_Δ',term_pat), 'Decomposed LMM, delta',
         fifelse(grepl('_0',term_pat), 'Decomposed LMM, baseline',
         fifelse(single_exam==T,       'Baseline-only', 'Primary longitudinal model'))))
   ][, .(met, Source, z, se)
]

ggplot(df, aes(x=met, y=z, fill=Source)) +
  geom_bar(stat='identity', position='dodge') +
  geom_errorbar(aes(ymin=z-1.96*se, ymax=z+1.96*se), position=position_dodge(0.9), width=0.3) +
  theme(axis.text.x=element_text(angle=45, hjust=1)) +
  xlab('Metabolite') + ylab('Z-score') +
  ggtitle('Comparison of metabolite*SNP term Z-score in different models')
```
