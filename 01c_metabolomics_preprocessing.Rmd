```{r, echo=F}
library(data.table)
library(matrixStats)
```

# Read & inspect data
```{r, cache=T, results="hold"}
ws_bucket <- "gs://fc-secure-4a392455-5587-4d6f-b8bd-01a1f834ae63"
data_files <- c(C8=paste0(ws_bucket,"/metabolomics/raw/MESA_pilot_BroadInst_C8-pos_lipids_050517.csv"),
                HP=paste0(ws_bucket,"/metabolomics/raw/MESA_pilot_BroadInst_HIL-pos_polar_050517.csv"),
                AN=paste0(ws_bucket,"/metabolomics/raw/an_MESA_clean.txt"))

dts <- sapply(data_files, \(path) fread(cmd=paste("gsutil cat", path)))

dts$C8[1:8,1:8] # What's the data look like?
dts$HP[1:8,1:8]
dts$AN[1:4,1:4]
```
Nonstandard format, so prepare for hardcoded row/col numbers!


# Extract metabolite metadata
Compound IDs may be duplicated across C8 and HP. A concatenated `<ID>_<Method>` variable ensures IDs are unique.\
Then, create a file mapping these IDs back to their metabolite metadata such as M/Z and RT.
```{r}
met_info <- list()
met_info$C8 <- dts$C8[seq(6,.N), 1:6]
met_info$HP <- dts$HP[seq(6,.N), 1:6]
met_info$AN <- data.table(method="Amine",
                          compound_id=NA, mz=NA, rt=NA, hmdb_id=NA,
                          name=names(dts$AN)[-1])
names(met_info$C8) <- names(met_info$HP) <- names(met_info$AN)
met_info <- rbindlist(met_info)

met_info[met_info=='' | met_info=='n/a'] <- NA

met_info[,                unique_met_id := paste0(compound_id,"_",method)]
met_info[method=="Amine", unique_met_id := name                          ] # Amines have no compound ID so just use name
#sum(duplicated(met_info$unique_id)) # No dup IDs!

fwrite(met_info, "met_info.csv")
head(met_info)
```


# Extract sample metadata
Note: MESA AN file has no sample metadata, so it is ignored here. All its sample IDs are covered by C8 and HP methods anyways.
```{r}
sample_info <- list()
sample_info$C8 <- transpose(dts$C8[1:5, .SD, .SDcols=(7:ncol(dts$C8))])
sample_info$HP <- transpose(dts$HP[1:5, .SD, .SDcols=(7:ncol(dts$HP))])
names(sample_info[[1]]) <- names(sample_info[[2]]) <- c("extr_date","inject_date","column","analysis_order","sample_id")
sample_info <- merge(sample_info$C8, sample_info$HP, by="sample_id", suffixes=c("_c8","_hp"), all=T)

# Rm all-NA rows, an artifact from the C8 file
sample_info <- sample_info[rowSums(!is.na(sample_info)) > 0]

sample_info[, is_control := !grepl("TOM",sample_id)]

write.csv(sample_info, "sample_info.csv")
head(sample_info)
```


# Extract measurement data
```{r, results="hold"}
dts$C8 <- dts$C8[, V6 := paste0(V2,"_",V1) ][, 1:5 := NULL ][-(1:4)] |> transpose(make.names=1) |> as.matrix(rownames=1)
dts$HP <- dts$HP[, V6 := paste0(V2,"_",V1) ][, 1:5 := NULL ][-(1:4)] |> transpose(make.names=1) |> as.matrix(rownames=1)
dts$AN <- dts$AN                                                                                |> as.matrix(rownames=1)
class(dts$C8) <- class(dts$HP) <- class(dts$AN) <- "numeric"
# ^ "NAs introduced by coersion" are due to 2 weird cells in dts$AN: "1+2559:2584.03935869994933" and "5+3828:3930.95273887971489"

dts$C8 <- dts$C8[rowSums(!is.na(dts$C8)) > 0,] # Rm all-NA rows artifact in the C8 file
dts$AN[dts$AN<0] <- NA # Amines has 2 negative measurements, which doesn't make sense

invisible(mapply(fwrite, dts, paste0(names(dts),"_cleaned.csv"), row.names=T))
#dts2 <- lapply(c(C8="C8_cleaned.csv",HP="HP_cleaned.csv",AN="AN_cleaned.csv"), \(f) as.matrix(fread(f),rownames=1)) # WARNING: as.matrix(rownames=1) bugged! See C8 col 24 ("TF03_C8-pos")).

dts$C8[1:4,1:4] # Check out the cleaned data!
dts$HP[1:4,1:4]
dts$AN[1:4,1:4]
```


# QC
1\. Remove signatures w/ variance = 0\
2\. Remove signatures w/ >25% missingness\
3\. Half-min Impute\
4\. Winsorize to 5*sd\
5\. Log2\
Missingness removal is done in two separate steps, where high-missingness metabolites are removed first, _then_ samples (to prioritize not losing samples).\
Batch adjustment is best done at the same time as adjusting for other covariates, later.
```{r}
winsorizeColsBySd <- \(m, n_sd) {
  cmeans <- colMeans(m,na.rm=T)
  csds   <- colSds  (m,na.rm=T)
  lower <- cmeans - n_sd*csds
  upper <- cmeans + n_sd*csds
  t(pmin(pmax(t(m),lower),upper)) # lower/upper are vectors of length ncol(m), recycled.
}

dts <- lapply(dts, \(m) {
  m <- m[, colVars(m) > 0] # step 1
  m <- m[,colSums(is.na(m)) < 0.25*nrow(m) ] # step 2a
  m <- m[ rowSums(is.na(m)) < 0.25*nrow(m),] # step 2b
  m[is.na(m)] <- (colMins(m,na.rm=T)/2)[col(m)[is.na(m)]] # step 3
  m <- winsorizeColsBySd(m,5) # step 4
  m <- log2(m+1) # step 5
})

invisible(mapply(fwrite, dts, paste0(names(dts),"_QCd_log2.csv"), row.names=T))
```



# Plots
## Skew vs. Kurtosis
```{r, results="hide"}
plotSkewKurt <- function(df, title) {
  n <- nrow(df); ms <- colMeans(df); sds <- colSds(df)
  skews <- sapply(1:ncol(df),\(col) (sum((df[,col]-ms[col])^3)/sds[col]^3)/n   )
  kurts <- sapply(1:ncol(df),\(col) (sum((df[,col]-ms[col])^4)/sds[col]^4)/n-3 )
  sk <- data.frame(skews=skews, kurts=kurts)

  {plot(sk$skews, sk$kurts, pch = 16, cex = 0.5, main = title, 
    xlab = "Skews", ylab = "Kurts", col = "black") +
   abline(v = -0.5, lty = 2,  lwd = 2) + 
   abline(v =  0.5, lty = 2,  lwd = 2) +
   abline(h = -2.0, lty = 2,  lwd = 2) +
   abline(h =  2.0, lty = 2,  lwd = 2)}
}
par(mfrow=c(1,3))
mapply(plotSkewKurt, dts, names(dts))
```






# Verbose versions of QC functions for testing (can ignore)
```{r, eval=F}
rm0VarCols <- \(m) {
  m[, cols2keep <- colVars(m) > 0]

  nms <- names(cols2keep)[which(!cols2keep)]
  cat(length(nms),"columns removed for 0 variance. Names:\n",nms,"\n")

  m
}

rmHighMissingnessRowsCols <- \(m, thresh) {
  m <- m[,cols2keep <- colSums(is.na(m)) < 0.25*nrow(m) ]
  m <- m[ rows2keep <- rowSums(is.na(m)) < 0.25*nrow(m),]

  r_nms <- names(rows2keep)[which(!rows2keep)]
  c_nms <- names(cols2keep)[which(!cols2keep)]
  cat(length(r_nms),"rows removed for >",scales::percent(thresh),"missingness. Names:\n",r_nms,"\n")
  cat(length(c_nms),"cols removed for >",scales::percent(thresh),"missingness. Names:\n",c_nms,"\n")

  m
}

# Slower but more readable half-min imputation
m <- apply(m, 2, \(col) { col[is.na(col)] <- min(col,na.rm=T)/2; col })
```
